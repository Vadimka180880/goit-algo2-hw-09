# Локальний пошук, евристики та імітація відпалу

Мінімізація **функції Сфери** в межах \(x_i \in [-5, 5]\) для кожного параметра \(x_i\).

$$
f(\mathbf{x}) = \sum_{i=1}^{n} x_i^2,\quad x_i \in [-5, 5]
$$

## Реалізовані методи

### 1. Hill Climbing (координатний *pattern search* + мультістарт)
- Перевіряє рухи \(\pm\)крок уздовж кожної осі.
- Якщо покращення немає — крок ділиться навпіл.
- Стійко збігається на Сфері.     

### 2. Random Local Search (мультістарт + локальний тюн)
- Багато випадкових точок у межах \([-5, 5]^n\).
- Дрібний локальний пошук навколо найкращої знайденої точки.

### 3. Simulated Annealing (SA)
- Гаусівські кроки зі стандартним правилом прийняття (Метрополіс).
- Повільне охолодження для кращого дослідження простору.


## Критерії зупинки

- **HC:** відсутність покращень на координатних кроках **та** максимальний крок стає меншим за поріг.
- **RLS:** вичерпання ітерацій (після глобального пошуку — локальний тюн).
- **SA:** температура \(T\) зменшується нижче `epsilon` або вичерпані ітерації.

## Як запустити

За замовчуванням приклад для 2D. Для \(n\)-вимірного випадку використовуйте `--dims`.

python main.py          # 2D за замовчуванням
python main.py --dims 5 # приклад n-вимірного випадку

## Параметри за замовчуванням

| Метод | Основні параметри |
|---|---|
| **HC** | `iterations=20000`, `step_frac=1.0`, `restarts=10`, `epsilon=1e-10` |
| **RLS** | `iterations=5000`, `restarts=5`, `epsilon=1e-8` |
| **SA** | `iterations=5000`, `temp=10.0`, `cooling_rate=0.99`, `epsilon=1e-8` |

 Межі для всіх методів: \(x_i \in [-5,5]\).

## Приклад результатів (2D)

Hill Climbing:
Розв'язок: [7.856910322345811e-07, -2.5402810432950673e-07] Значення: 6.818406759230843e-13

Random Local Search:
Розв'язок: [0.0012382172168572958, -0.0006142393220544117] Значення: 1.9104718208796907e-06

Simulated Annealing:
Розв'язок: [0.001953331737596071, -0.00222896532991404] Значення: 8.783791319058891e-06

## Висновки

- **HC (pattern search)** на Сфері дає найкраще наближення (стійка й монотонна збіжність).
- **RLS** швидко знаходить близько-нульові точки, простий і добре паралелиться, але залежить від кількості ітерацій.
- **SA** «витривалий» до локальних мінімумів і показує гарні результати; точність керується `iterations` та швидкістю охолодження.

